---
marp: true
math: mathjax
---

<h1><center>计算机程序设计小班辅导</center></h1>

<h2><center>2025.11.09 王哲凡</center></h2>

---

# 目录

- 数据类型与输入输出
- 数据存储与进制转换
- 常量与运算符
- 运算符优先级、结合性与常用标准库函数
- 判断与循环
- 数组
- 函数
- 变量作用域
- 往年题目解析

---

# 数据类型与输入输出
> 常见数据类型、类型信息、输入输出标准库函数

---

# 基本数据类型

| 数据类型     | 占用字节数 | 取值范围                          | 格式化控制符 |
|:------------:|:----------:|:---------------------------------:|:--------------------:|
| `short`      | 2          | $-2^{15}$ 到 $2^{15}-1$                 | %hd                  |
| `int`        | 4          | $-2^{31}$ 到 $2^{31}-1$ | %d                   |
| `long long` | 8          | $-2^{63}$ 到 $2^{63}-1$ | %lld                 |
| `float`      | 4          | 约 $\pm 1.5 \times 10^{-45}$ 到 $\pm 3.4 \times 10^{38}$ | %f                   |
| `double`     | 8          | 约 $\pm 5.0 \times 10^{-324}$ 到 $\pm 1.7 \times 10^{308}$ | %lf                  |
| `char`       | 1          | $-2^{7} (-128)$ 到 $2^{7} - 1(127)$                    | %c                   |
| `bool`       | 1          | true (1) / false (0)              | /                   |

其中除了 `float` 和 `double` 之外，其他类型均为整数类型，前 5 种均包含对应的无符号类型，如 `unsigned int`，实际上一般类型的 `signed` 可省略不写。

---

# 类型基本信息

我们可以通过 `sizeof` 运算符来获取数据类型/变量所占用的字节数，例如：
```c
#include <stdio.h>
int main() {
    printf("Size of int: %zu bytes\n", sizeof(int));
    printf("Size of double: %zu bytes\n", sizeof(double));
    return 0;
}
```

一般情况下，输出即为：
```
Size of int: 4 bytes
Size of double: 8 bytes
```

除此之外，还有一些常见的常量如 `INT_MAX`、`FLT_MAX` 等可以获取对应类型的取值范围，这些常量定义在头文件 `<limits.h>`（整数类型）和 `<float.h>`（浮点类型）中。

---

# 输入输出
- 常用输入输出函数：`printf` 与 `scanf`，基本使用方式如 `scanf("%d", &a);` 与 `printf("%d\n", a);`
  - 其中 `%d` 为格式化控制符，用于指定输入输出的数据类型与表示方式
  - `&a` 表示变量 `a` 的地址，用于存储输入的数据，特别注意 `scanf` 需要传入地址（写入变量），而 `printf` 传入变量本身（仅需读取变量）
  - 常见格式化控制符如前述数据类型表所示，如 `%f` 表示浮点数，`%c` 表示字符等
- 其他常用格式化控制符：
  - `%s`：字符串
  - `%p`：指针地址
  - `%%`：输出百分号 `%`

---

# 输入输出（格式化控制符详解）

- 实际上完整的格式化控制符形如 `%[parameter][flags][width][.precision][length]type`，但大部分情况下仅需使用 `type` 即可
  - 其中 `[parameter]` 对应参数列表中的位置（一般不用）
  - `[flags]` 包含一些修饰符（对齐、正负号、补零、特殊进制前缀等）
  - `[width]` 与 `[.precision]` 分别表示输出的最小宽度（注意不等于有效位数）与小数点后的位数
  - `[length]` 用于指定数据类型的长度（如 `l` 表示 `long`，`ll` 表示 `long long`，`z` 表示 `size_t` 等）
  - `type` 表示数据类型，如 `d` 表示十进制整数（decimal，类似还有八进制 `o`，十六进制 `x` 等），`u` 表示无符号整数（unsigned），`f` 表示浮点数（float），`c` 表示字符（char）等

---

# 输入输出（其他注意事项）

- 一般输入输出的字符串中，我们会使用转义字符来表示特殊字符，如 `\n` 表示换行，`\t` 表示制表符（Tab），`\\` 表示反斜杠 `\` 本身等
- `scanf("%d%d%d", &a, &b, &c);` 可一次性输入多个整数，空格、换行等均可作为分隔符，但如果使用 `scanf("%d,%d,%d", &a, &b, &c);` 则必须在输入时用逗号 `,` 进行分隔，否则会导致输入失败
- 其他输入输出函数：
  - `getchar()` 与 `putchar()`：用于输入/输出单个字符，因此参数类型一般为 `char`
  - `_getch()`、`_getche()`：Windows 平台下用于输入单个字符，前者不回显，后者回显，用处极少，可以忽略
  - `gets()` 与 `puts()`：用于输入/输出字符串，`gets()` 已不推荐使用，建议使用 `fgets()` 代替，`puts()` 可用于输出字符串并自动换行

---

# 数据存储与进制转换
> 数据在计算机中的存储形式与不同进制间的转换

---

# 整型数据：原码、反码与补码

- **原码**：符号位 + 数值位
- **反码**：符号位不变，数值位按位取反（仅对于负数）
- **补码**：反码 + 1 （仅对于负数）
- 计算机中整数均以补码形式存储与运算
- 补码的优点：加减法统一，且只有唯一的零表示
- 举例：假设用 $4$ 位二进制表示整数
  - $+3$ 的原码、反码与补码均为 $0011$
  - $-5$ 的原码为 $1101$，反码为 $1010$，补码为 $1011$
  - 计算 $3 - 5$ 可转化为 $3 + (-5)$，即 $0011 + 1011 = 1110$，结果为 $-2$ 的补码
- 实际上，对于 $n$ 位二进制数，一个负数 $-x$ 的补码可直接通过 $2^n - x$ 得到，加减法通义本质上是通过在 $2^n$ 位上的**溢出**来实现的（忽略溢出位）

---

# 浮点型数据：IEEE 754 标准

- 浮点数由符号位 $S$、阶码 $E$ 与尾数 $M$ 组成
- 以单精度浮点数为例（32 位）：
    - $1$ 位符号位 $S$：$0$ 表示正数，$1$ 表示负数
    - $8$ 位阶码 $E$：存储的是实际指数加上一个偏移量 $127$（即**移码表示**）
    - $23$ 位尾数 $M$：存储的是有效数字的小数部分，实际尾数为 $1.M$（即**隐含的最高位**）
- 浮点数的值可表示为：$(-1)^S \times (1.M)_2 \times 2^{E - 127}$
- 单精度 `float` 的有效数字约为 $7$ 位十进制数，双精度 `double` 约为 $16$ 位十进制数

---

# 进制转换

- 常见进制：二进制（Base 2）、八进制（Base 8）、十进制（Base 10）、十六进制（Base 16）
- $q$ 进制转为十进制：将各位数字乘以对应的权值并相加
  - 例如，$(101.01)_2 = 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 0 \times 2^{-1} + 1 \times 2^{-2} = 5.25_{10}$
- 十进制转为 $q$ 进制：不断地用 $q$ 除以 $n$，直到 $n$ 为 $0$，然后将余数逆序排列
  - 例如，$(13)_{10} = (1101)_2$
- 特殊进制转换：
  - 二进制与八进制：每 $3$ 位二进制对应 $1$ 位八进制
  - 二进制与十六进制：每 $4$ 位二进制对应 $1$ 位十六进制，如 $(1110 1011)_2 = \text{0xEB}$

---

# C 语言中的进制转换

```c
printf("%05o\n", 35);    //按八进制格式输出，保留 5 位高位补零
printf("%03d\n", 35);    //按十进制格式输出，保留 3 位高位补零
printf("%05x\n", 35);    //按十六进制格式输出，保留 5 位高位补零
```

结果：
```
00043
035
00023
```

---

# 常量与运算符
> `const`、加减乘除等

---

# 常量表示

```c
#define PI 3.14159      // 宏定义常量
const int MAX_SIZE = 100; // const 常量
```
一般**推荐**使用 `const` 来定义常量，因为它具有类型检查功能，且作用域更明确，`#define` 宏定义常量则更像是文本替换，可能在一些宏函数情况下引发意外错误。
> **经典案例**：`#define SQUARE(x) x * x`，当调用 `SQUARE(1 + 2)` 时，实际展开为 `1 + 2 * 1 + 2`，结果为 `5` 而非预期的 `9`。

---

# 算术运算符

- `+`、`-`、`*`、`/`、`%`：分别表示加、减、乘、除与取模运算
- 注意整数除法与浮点数除法的区别：
  - 整数除法：结果向下取整，例如 `5 / 2` 结果为 `2`
  - 浮点数除法：结果为精确的浮点数，例如 `5.0 / 2.0` 结果为 `2.5`
- 取模运算 `%` 仅适用于整数类型，表示除法的余数，例如 `5 % 2` 结果为 `1`
- 特别注意对于负数的情况，在 C/C++ 种，`/` 可理解为**绝对值的下取整**加上符号（负负得正），而 `%` 结果的符号则与被除数符号相同，例如 `-5 / 2 = -2`，`-5 % 2 = -1`
  - > 与 Python 等语言不同，Python 中 `-5 // 2 = -3`，`-5 % 2 = 1`，保证 `%` 结果非负
  - 但无论哪种语言，都保证 `a = (a / b) * b + (a % b)` 恒成立

---

# 算术运算符（续）

- `++` 与 `--`：分别表示自增与自减运算
  - **前缀形式**（如 `++a`）：先进行自增/自减操作，再使用变量的值
  - **后缀形式**（如 `a++`）：先使用变量的值，再进行自增/自减操作
- 注意在表达式中混用前缀与后缀形式可能导致结果未定义，建议避免这种用法
- 示例：
  - ```c
    int a = 5;
    int b = ++a; // a 变为 6，b 也为 6
    int c = a++; // c 为 6，a 变为 7
    ```

---

# 位运算符

- `&`：按位与运算符，对应位均为 `1` 则结果为 `1`，否则为 `0`
- `|`：按位或运算符，对应位有一个为 `1` 则结果为 `1`，否则为 `0`
- `^`：按位异或运算符，对应位不同则结果为 `1`，否则为 `0`
- `~`：按位取反运算符，将每一位取反
- `<<`：左移运算符，将二进制数向左移动指定的位数，右侧补 `0`
- `>>`：右移运算符，将二进制数向右移动指定的位数，左侧补符号位（算术右移）

---

# 关系运算符与逻辑运算符

- 关系运算符：`==`（等于）、`!=`（不等于）、`>`（大于）、`<`（小于）、`>=`（大于等于）、`<=`（小于等于）
- 逻辑运算符：`&&`（逻辑与）、`||`（逻辑或）、`!`（逻辑非）
- 关系运算符的结果为布尔值，`true`（非零）或 `false`（零）
- 逻辑运算符的**短路特性**：
  - 对于 `&&`，如果左侧为 `false`，则右侧不再计算
  - 对于 `||`，如果左侧为 `true`，则右侧不再计算
- 注意区分赋值运算符 `=` 与等于运算符 `==`，前者用于赋值，后者用于比较

---

# 赋值运算符与赋值表达式

在 C 语言中，赋值运算符 `=` 用于将右侧的值赋给左侧的变量。赋值表达式的结果为赋值后的变量值。 例如：
```c
int a;
a = 5;          // 将 5 赋值给 a
int b = (a = 10); // 先将 10 赋值给 a，然后将表达式 (a = 10) 的返回值赋给 b（也为 10）
```
除了基本的赋值运算符 `=`，C 语言还提供了复合赋值运算符，如 `+=`、`-=`、`*=`、`/=` 等，用于简化对变量的操作。例如：
```c
a += 3; // 等价于 a = a + 3;
b *= 2; // 等价于 b = b * 2;
```

---

# 赋值运算符与赋值表达式（续）

特别地，当赋值运算符两侧的类型不同时，C 语言会进行**隐式类型转换**，将右侧的值转换为左侧变量的类型后再进行赋值。例如：
```c
int a;
double b = 5.7;
a = b; // b 的值 5.7 会被转换为整数 5（向零取整）后赋值给 a
```

为了避免隐式类型转换带来的潜在问题，建议在赋值时确保两侧的类型一致，或者使用显式类型转换（强制类型转换）来明确转换意图。例如：
```c
a = (int)b; // 显式将 b 转换为 int 类型后赋值给 a
a = (int)(b + 0.5); // 四舍五入后赋值给 a，建议用括号包含整个表达式
```

---

# 隐式类型转换

实际上，只要在表达式中混合使用不同类型的数据，C 语言都会进行隐式类型转换。隐式类型转换遵循一定的规则，通常会将较小范围的类型转换为较大范围的类型。例如：
```c
int a = 5;
double b = 2.3;
double c = a + b; // a 会被隐式转换为 double 类型，结果为 7.3
```

类似的，在函数调用时，如果传入的参数类型与函数定义中的参数类型不匹配，C 语言也会进行隐式类型转换。例如：
```c
void func(double x) {
    // ...
}
int main() {
    int a = 10; func(a); // a 会被隐式转换为 double 类型
}
```

---

# 数值常量指定类型

在 C 语言中，数值常量默认具有特定的类型，但可以通过后缀来指定不同的类型。例如：
- 整数常量：
  - `42`：默认类型为 `int`
  - `42u` 或 `42U`：无符号整数类型 `unsigned int`
  - `42ll` 或 `42LL`：长长整数类型 `long long`
  - `42ul` 或 `42UL`：无符号长整数类型 `unsigned long`
- 浮点数常量：
  - `3.14`：默认类型为 `double`
  - `3.14f` 或 `3.14F`：单精度浮点数类型 `float`
  - `3.14l` 或 `3.14L`：长双精度浮点数类型 `long double`

---

# 其他运算符

- `sizeof`：用于获取数据类型或变量所占用的字节数
- `&`：取地址运算符，返回变量的内存地址，注意与按位与运算符区分
- `*`：指针运算符，用于声明指针变量或获取指针所指向的值
- `?:`：条件运算符（三元运算符），用于根据条件表达式的真假选择不同的值
  - 语法：`condition ? value_if_true : value_if_false`
  - 例如：`int max = (a > b) ? a : b;`
  - 注意条件运算符的优先级较低，建议使用括号明确表达式的计算顺序
- `,`：逗号运算符，用于在一个表达式中依次计算多个子表达式，并**返回最后一个子表达式的值**，如 `a = (b = 3, b + 2);`，此时 `a` 的值为 `5`，`b` 的值为 `3`。
- `.` 和 `->`：成员访问运算符，分别用于通过结构体变量和结构体指针访问成员（暂未涉及结构体内容，可忽略）

---

# 运算符优先级、结合性与常用标准库函数
> 各类运算符优先级高低、左结合与右结合、常用标准库函数

---

# 运算符优先级与结合性

| 优先级 | 类别 | 运算符 | 结合性 |
|:------:|:----:|:------:|:------:|
| 1 | 后缀 | `()` `[]` `->` `.` `++` `--` | 从左到右 |
| 2 | 一元 | `+` `-` `!` `~` `++` `--` `(type)` `*` `&` `sizeof` | **从右到左** |
| 3 | 乘除 | `*` `/` `%` | 从左到右 |
| 4 | 加减 | `+` `-` | 从左到右 |
| 5 | 移位 | `<<` `>>` | 从左到右 |
| 6 | 关系 | `<` `<=` `>` `>=` | 从左到右 |
| 7 | 相等 | `==` `!=` | 从左到右 |
| 8 | 位与 AND | `&` | 从左到右 |

---

# 运算符优先级与结合性（续）

| 优先级 | 类别 | 运算符 | 结合性 |
|:------:|:----:|:------:|:------:|
| 9 | 位异或 XOR | `^` | 从左到右 |
| 10 | 位或 OR | `\|` | 从左到右 |
| 11 | 逻辑与 AND | `&&` | 从左到右 |
| 12 | 逻辑或 OR | `\|\|` | 从左到右 |
| 13 | 条件 | `condition?x:y` | **从右到左** |
| 14 | 赋值 | `=` `+=` `-=` `*=` `/=` `%=` `>>=` `<<=` `&=` `^=` `\|=` | **从右到左** |
| 15 | 逗号 | `,` | 从左到右 |

尽管了解运算符优先级与结合性有助于理解复杂表达式的计算顺序，但在实际编程中，**建议使用括号明确表达式的计算顺序**，以提高代码的可读性和可维护性。

---

# 常用标准库函数（一）

- `string.h`：包含大量字符串、数组和内存操作的函数。
  - `memset(void *ptr, int value, size_t num)`：将内存块 `ptr` 的前 `num` 个字节设置为指定的 `value`。
  - `memcpy(void *dest, const void *src, size_t num)`：将内存块 `src` 的前 `num` 个字节复制到内存块 `dest`。
  - `strlen(const char *str)`：返回字符串 `str` 的长度（直到终止符 `\0`，不包括终止的空字符）。
  - `strcpy(char *dest, const char *src)`：将字符串 `src` 复制到 `dest`，包括终止符 `\0`。类似还有 `strncpy`、`strcat`、`strcmp` 等函数，分别用于字符串复制（前 $n$ 个字符）、连接和比较。
  - `getline(char **lineptr, size_t *n, FILE *stream)`：从指定的输入流 `stream` 读取一行文本，自动分配或扩展缓冲区以存储读取的行（可忽略）。

---

# 常用标准库函数（二）

- `ctype.h`：包含一些简单转换。
  - `tolower(int c)`：将字符 `c` 转换为小写字母（如果可能）。
  - `toupper(int c)`：将字符 `c` 转换为大写字母（如果可能）。
  - `isdigit(int c)`：检查字符 `c` 是否为数字字符。
  - `isalpha(int c)`：检查字符 `c` 是否为字母字符。
  - `isspace(int c)`：检查字符 `c` 是否为空白字符（空格、制表符、换行等）。
  - `isprint(int c)`：检查字符 `c` 是否为可打印字符（非控制字符，包括空格）。

---

# 常用标准库函数（三）

- `math.h`：包含一些常用数学函数。
  - `sqrt(double x)`：计算 `x` 的平方根。
  - `pow(double base, double exponent)`：计算 `base` 的 `exponent` 次幂。
  - `sin(double x)`、`cos(double x)`、`tan(double x)`：分别计算 `x` 的正弦、余弦和正切值（`x` 以弧度为单位）。
  - `log(double x)`：计算自然对数（以 e 为底）。
  - `exp(double x)`：计算 e 的 `x` 次幂。
  - `floor(double x)/ceil(double x)`：分别返回小于等于 `x` 的最大整数和大于等于 `x` 的最小整数（上下取整），注意返回值类型为 `double`。
  - `abs(int x)/fabs(double x)`：分别返回整数 `x` 和浮点数 `x` 的绝对值。
  - `asin(double x)`、`sinh(double x)` 等其他三角函数及其反函数。

---

# 标准库函数使用注意事项

- 使用标准库函数前，需包含对应的头文件，如 `#include <string.h>`、`#include <math.h>` 等。
- 注意函数的参数类型与返回值类型，确保传入正确的类型以避免隐式类型转换带来的问题。
- 某些函数可能会修改传入的参数（如 `memset`、`memcpy` 等），需确保传入的指针指向有效的内存区域。
- 对于涉及浮点数运算的函数，需注意浮点数的精度问题，避免因精度误差导致的计算错误。
- 使用 `math.h` 中的函数时，需链接数学库（在某些编译器中需要添加 `-lm` 选项）。

---

# 判断与循环
> `if`、`switch`、`while`、`for` 等

---

# `if` 语句

```c
if (condition) {
    // 条件为真时执行的代码
} else {
    // 条件为假时执行的代码
} // else 部分也可以省略（如果不需要）
```

当然，如果代码块只有一行，可以省略大括号 `{}`，但**不推荐**在不熟悉代码时这样做，以免引发潜在的逻辑错误。

特别地，`if (a)` 可理解为 `if (a != 0)`，即非零即为真，零即为假，同样 `if (!a)` 可理解为 `if (a == 0)`。

---

# `switch` 语句

```c
switch (expression) {
    case constant1:
        // 当 expression 等于 constant1 时执行的代码
        break;
    case constant2:
        // 当 expression 等于 constant2 时执行的代码
        break;
    // 可以有任意数量的 case 分支
    default:
        // 当 expression 不匹配任何 case 时执行的代码（可选）
}
```
---

# `switch` 语句注意事项

- `expression` 的返回值/结果必须为整数类型（如 `int`、`char` 等）
- 每个 `case` 标签后面必须跟一个常量表达式，且各 `case` 标签的值必须唯一
- `break` 语句用于跳出 `switch` 语句，否则会发生**贯穿效应**（fall-through），即执行完匹配的 `case` 后继续执行后续的 `case` 代码，直到遇到 `break` 语句或 `switch` 语句结束。非常不建议省略 `break`，除非确实需要这种行为
- `default` 分支是可选的，用于处理所有未匹配的情况
- `switch` 语句的 `case` 标签可以是常量、枚举值或字符串字面量（在 C++ 中）
- 每个 `case` 下均为独立的代码块，可以包含任意数量的语句，不需要额外添加大括号 `{}`

---

# `while` 循环

```c
while (condition) {
    // 条件为真时执行的代码块
}
```

运行逻辑：
- 首先判断 `condition`，如果为真（非零），则执行代码块
- 执行完代码块后，再次判断 `condition`，重复上述过程，直到 `condition` 为假（零）时跳出循环
- 即整体运行流程为：判断 → 执行 → 判断 → 执行 → ... → 判断 → 跳出
- 判断内部也可以包含复杂表达式，如 `while (scanf("%d", &x) == 1)`，表示只要成功读取一个整数，就继续循环
- 可以用 `while (1)` 来做到死循环

---

# `for` 循环

```c
for (initialization; condition; update) {
    // 条件为真时执行的代码块
}
```

运行逻辑：
- 首先执行 `initialization`，通常用于初始化循环变量
- 然后判断 `condition`，如果为真（非零），则执行代码块
- 执行完代码块后，执行 `update`，通常用于更新循环变量
- 重复判断 `condition`，执行代码块，更新变量的过程，直到 `condition` 为假（零）时跳出循环
- 初始化 → 判断 → 执行 → 更新 → 判断 → 执行 → 更新 → ... → 判断 → 跳出
- `for (;;)` 可实现死循环，三部分均可省略

---

# `for` 循环（续）

- 当 `condition` 初始即为假时，代码块不会执行，若为空，表示无限循环
- 可以用 `while` 循环近似实现 `for` 循环的功能（但并不完全一致），例如：
```c
initialization;
while (condition) {
    // 代码块
    update;
}
```
- `for` 循环的初始化部分可以声明变量，例如 `for (int i = 0; i < n; i++)`，此时变量 `i` 的作用域仅限于 `for` 循环内部
  - 比较建议这么定义循环变量，可以有效限制变量的作用域
- `for` 循环的更新部分可以包含多个表达式，用逗号分隔，例如 `for (int i = 0, j = n; i < j; i++, j--)`

---

# `do...while` 循环

```c
do {
    // 执行的代码块
} while (condition);
```

与 `while` 循环的区别在于，`do...while` 循环**至少会执行一次代码块**，因为条件判断是在代码块执行之后进行的。运行逻辑如下：
- 首先执行代码块
- 然后判断 `condition`，如果为真（非零），则继续执行代码块
- 重复上述过程，直到 `condition` 为假（零）时跳出循环
- 执行 → 判断 → 执行 → 判断 → ... → 判断 → 跳出
- 实际使用中较少用到，通常可以用 `while` 或 `for` 循环替代：`statement; while (condition) { statement; }`

---

# 循环控制语句

- `break`：用于立即跳出当前循环或 `switch` 语句，结束循环的执行
  - 注意在多重嵌套循环中，`break` 仅跳出**最内层**的循环
- `continue`：用于跳过当前循环的剩余部分，直接进入下一次循环的判断
  - 同样在多重嵌套循环中，`continue` 仅影响**最内层**的循环
  - 在 `for` 循环中，`continue` 会先执行更新部分，然后再进行条件判断，因此这部分与 `while` 模拟效果有所不同
- `goto`：用于无条件跳转到程序中的指定标签位置，通常不推荐使用，因为它会破坏程序的结构化，导致代码难以理解和维护
  - ```c
    goto label;
    ...
    label: statement;
    ```

---

# 数组
> 一维数组、多维数组、字符数组等

---

# 数组：带下标的相互关联的变量序列

数组是计算机语言提供的组织多个数据的一种重要方式：
- 提供了多个同类型的数据（值）在内存中连续存放的工具；
- 提供了对大量内存单元进行高效"命名"的途径；
- 提供了在程序运行过程中动态改变"变量名称"的手段；
- 是一些重要算法思想的实现基础。

---

# 数组的定义

```c
const int SIZE = 100; // 定义数组大小的常量
int arr[SIZE];        // 定义一个包含 SIZE 个整数的一维数组
char str[SIZE / 10];  // 定义一个包含 SIZE/10 个字符的一维数组
```

特别注意，尽管在 C 标准中，可以试用变长数组（VLA），但在某些编译器中可能不被支持，且其使用存在一些限制，因此**建议仅使用固定大小的数组**。

---

# 数组元素

在 C 语言中，数组元素在内存中连续存放，因此数组占用的总字节数等于数组元素个数乘以每个元素的字节数。例如：
```c
int arr[10]; // 假设 int 类型占 4 字节，则 arr 占用 40 字节
```

可以通过引用 `[]` 来访问数组元素，数组下标从 `0` 开始。例如：
```c
arr[0] = 5;    // 访问第一个元素
int x = arr[3]; // 访问第四个元素
```
**特别注意**，访问数组时必须确保下标在合法范围内（`0` 到 `SIZE - 1`），否则会导致未定义行为。

`[]` 中的下标可以是常量、变量或表达式，但必须是整数类型。

---

# 数组的初始化

数组可以也只能在定义时进行初始化（即不能 `int a[5]; a = {1, 2, 3, 4, 5};`），例如：
```c
int arr[5] = {1, 2, 3, 4, 5}; // 初始化数组的前 5 个元素
int arr2[] = {10, 20, 30};    // 根据初始化列表自动推断大小为 3，等价于 int arr2[3] = {10, 20, 30};
int arr3[5] = {3, 4};         // 初始化前 2 个元素为 3 和 4，其他元素自动初始化为 0
char str[] = "Hello";        // 初始化字符数组，等价于 char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```
注意对 `char` 数组初始化时，字符串字面量会自动在末尾添加终止符 `\0`，因此数组大小应至少为字符串长度加 `1`。

---

# 高维数组

高维数组是数组的数组，例如二维数组可以看作是一个矩阵，三维数组可以看作是一个立体数据结构。定义方式如下：
```c
int matrix[3][4];        // 定义一个 3 行 4 列的二维数组
char cube[2][3][4];     // 定义一个 2 层 3 行 4 列的三维数组
```
访问高维数组元素时，需要提供多个下标，例如：
```c
matrix[1][2] = 5;       // 访问二维数组的第 2 行第 3 列元素
cube[0][1][3] = 'a'; // 访问三维数组的第 1 层第 2 行第 4 列元素
```

---

# 高维数组与一维数组的关系

实际上，高维数组在内存中也是以一维数组的形式存储的。
以二维数组为例，`matrix[3][4]` 在内存中连续存放了 `3 * 4 = 12` 个整数。
访问二维数组元素时，可以通过计算偏移量来实现。例如，访问 `matrix[i][j]` 实际上对应于一维数组中的 `matrix[i * 4 + j]`。
但是由于两种数据类型的区别，不能简单将二维数组名用于一维数组的引用。

实际上，数组名也可以理解为一个常量指针，指向数组的首元素，`a[i]` 这样的运算其实就相当于 `*(a + i)`，`&a[i]` 则相当于 `a + i`。
因此，读入数组也可以使用 `scanf("%d", a + i)` 的方式。
> 对于高维数组，其数组名实际上是指向数组首行的行指针，类型既不是 `int**` 也不是 `int*`，而是 `int (*)[列数]`（列数不同，类型也不同）。

---

# 字符数组

一般我们所说的字符串，实际上是以字符数组的形式存储的，并以特殊的终止符 `\0`（ASCII 码为 `0`）结尾，由于字符类型 `char` 也是一种特殊的整数类型，因此可以使用整数的方式来处理字符数组。

前面提到的标准库函数中，有许多用于处理字符串的函数，如 `strlen`、`strcpy`、`strcat`、`strcmp` 等，均可用于字符数组的操作。
同时 `%s` 格式控制符也可用于输入输出字符串。

---

# 函数
> 函数的定义、声明与调用，递归

---

# 函数的定义与声明

```c
return_type function_name(parameter_list) {
    // 函数体
}
```

注意：
- `return_type`：函数的返回类型，可以是基本数据类型、指针类型或 `void`（表示无返回值，可以省略但不建议）
- `function_name`：函数的名称，遵循标识符命名规则
- `parameter_list`：函数的参数列表，可以为空或包含多个逗号分隔的参数
- 函数定义可以放在 `main` 函数之前或之后，但如果放在之后，则需要在使用前进行函数声明（原型），例如：`return_type function_name(parameter_list);`（可以省略参数名称，只保留类型）

---

# 函数定义示例

```c
int add(int a, int b) {
    return a + b; // 返回两个整数的和
}

void printMessage() {
    printf("Hello, World!\n"); // 打印消息，无返回值
}
```

C 语言中不允许嵌套定义函数，即不能在一个函数内部定义另一个函数。
> 但其他语言如 Python、JavaScript 等允许嵌套定义函数。
> C++ 等则允许 lambda 表达式等定义匿名函数。

---

# 函数调用

一般我们在说到函数参数时，包含形式参数和实际参数：
- **形式参数**（形参）：函数定义中使用的参数变量，用于接收传入的值（比如上面的 `add` 函数中的 `a` 和 `b`）
- **实际参数**（实参）：函数调用时传入的具体值或变量（比如 `add(5, 10)` 中的 `5` 和 `10`）
- 形式参数就像是函数内部的局部变量，实参的值会被复制给形参，在运行结束后形参会被销毁
- **注意**：在 C 语言中，函数参数是按值传递的，即实参的值会被复制到形参中，形参的修改不会影响实参的值。
- 形参与实参的类型、数量和顺序必须匹配，否则会导致编译错误或未定义行为。

---

# 数组作为函数参数

```c
void processArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2; // 将数组元素乘以 2
    }
}
```

注意：
- 数组的传参本质是传递数组首元素的地址，因此在函数内部对数组元素的修改会影响到原数组（区分普通的值传递）
- 在函数参数中，`int arr[]` 和 `int *arr` 是等价的，表示传递一个指向整数的指针，同时，`[]` 内部的大小没有实际意义
- 在函数内部可以使用指针运算来访问数组元素，例如 `*(arr + i)` 等价于 `arr[i]`

---

# 多维数组作为函数参数

```c
void processMatrix(int matrix[][4], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 4; j++) {
            matrix[i][j] += 1; // 将矩阵元素加 1
        }
    }
}
```

注意：
- 对于多维数组，必须指定出第一个维度外的其他维度大小，以便正确计算偏移量（本质是对齐数组行指针的数据类型）
- 传递多维数组时，仍然是传递数组首行的地址，因此在函数内部对数组元素的修改会影响到原数组
- 函数声明时也需要指定多维数组后几个维度大小（本质还是数据类型相同）

---

# 函数递归

```c
int fibonacci(int n) {
    if (n <= 1) return n; // 基本情况
    return fibonacci(n - 1) + fibonacci(n - 2); // 递归调用
}
```
一般递归函数可以简单分为三个部分：
- 递归终止条件：用于判断何时停止递归，防止无限递归（如上例中的 `if (n <= 1)`）
- 递归调用过程：将任务分解为更小的子任务（如上例中的 `fibonacci(n - 1)` 和 `fibonacci(n - 2)`），同时准备好传递给子任务的参数（需要注意一些变量的修改和还原）
- 子任务的结果合并：将子任务的结果进行合并，得到最终结果（如上例中的加法操作）

---

# 函数调用栈

```c
void func3() { /* do something (1) */ }
void func2() { /* do something (2) */ func3(); /* do something (3) */ }
void func1() { /* do something (4) */ func2(); /* do something (5) */ func3(); /* do something (6) */ }
int main() { func1(); return 0; }
```

容易想到执行顺序如下：
```
func1 (4) 
  -> func2 (2) 
      -> func3 (1) 
  -> func2 (3) 
  -> func3 (6)
```

---

# 函数调用栈（续）

如果用栈来表示整个过程，即为如下：
- `func1` 入栈，执行 (4)，`func2` 入栈，执行 (2)，`func3` 入栈，执行 (1)，`func3` 出栈，执行 (6)，`func2` 出栈，执行 (3)，`func1` 出栈
$$
\begin{array}{}  \varnothing & \to & f1 & \to & f1 & \to & f1 & \to & f1 & \to & f1 & \to & f1 & \to & f1 & \to & \varnothing \\  & & & & f2 & & f2 & & f2 & & & & f3 \\  & & & & & & f3 \\  \end{array}
$$
也就是，当一个函数（包括主函数）执行到某一步时，如果需要调用另一个函数（包括它自己）时，就会先执行另一个函数，执行完再回来执行当前函数的后续部分。
看起来调用函数就是一个将函数入栈的过程，返回（`return`）或函数自然结束则是一个函数出栈的过程。

---

# 变量作用域
> 局部变量与全局变量

---

# 语句块

一般可以通过大括号 `{}` 来定义一个语句块（复合语句），例如：
```c
{
    int x = 10;
    printf("%d\n", x);
}
```
同样，对于每个函数的定义体本质上也是一个语句块。

---

# 全局变量

目前我们暂时只考虑单个源文件的情况，在这种情况下，**全局变量**是定义在所有函数之外的变量，例如：
```c
int globalVar = 100; // 全局变量
void func() {
    printf("%d\n", globalVar); // 访问全局变量
}
```
全局变量的作用域是从定义处开始，到文件末尾结束，可以在所有函数中访问（在其之后定义的函数）和修改全局变量（只要不是 `const` 常量）。

---

# 局部变量

在一个语句块/代码块中定义的变量称为**局部变量**，例如：
```c
void func() {
    int localVar = 50; // 局部变量
    for (int i = 0; i < 5; i++) { // 循环变量也是局部变量
        int loopVar = i * 2; // 循环内的局部变量
        printf("%d ", loopVar);
    }
    printf("%d\n", localVar); // 访问局部变量
}
```
它们只能在定义它们的语句块/代码块内部访问，出了这个范围就无法访问了，会被自动销毁。

---

# 变量命名规则

- 除了基本的标识符命名规则外，局部变量之间以及全局变量与局部变量还可以共享相同名称：
  - 需要两个变量的作用域不重叠，或呈现真包含关系
  - 在作用域重叠时，更小作用域的局部变量优先级更高，因此在访问变量时会优先使用更小作用域的局部变量
  - 例如：
  - ```c
    int var = 10; // 全局变量
    void func() {
        int var = 20; // 局部变量，遮蔽了全局变量
        printf("%d\n", var); // 输出 20
    }
    ```

---

# 函数作用域

在多文件编程时，函数根据作用域也可以分为**内部函数**和**外部函数**：
- 内部函数：使用 `static` 关键字修饰的函数，其作用域仅限于定义它的源文件，不能被其他源文件访问
- 外部函数：未使用 `static` 修饰的函数，其作用域为整个程序，可以被其他源文件访问（需要通过函数声明），也可以额外使用 `extern` 关键字在其他源文件中引用（默认省略）
- 使用 `static` 修饰函数可以有效避免命名冲突，提高代码的封装性和安全性

---

# 往年题目解析
> 2023 年期中考试部分题目解析

---

# C 语言单词处理（1，5 分）

函数 `void MyReplace(char str[])` 
- 该函数的功能是将字符串 `str` 中所有非英文字母替换成为空格字符，即将 `str` 中不为 `a`~`z` 或者不为 `A`~`Z` 的字符全变成空格，替换后的字符串仍存于 `str` 中。
- 在函数内输出替换后的 `str`。

---

# C 语言单词处理（1）分析

我们需要遍历完整的字符串，对于每个字符，判断它是否为英文字母，如果不是，则将其替换为空格字符 `' '`。可以使用 `isalpha` 函数来判断字符是否为字母或者直接比较字符的 ASCII 码范围。
```c
#include <ctype.h> // 包含 isalpha 函数的头文件
void MyReplace(char str[]) {
    for (int i = 0; str[i] != '\0'; ++i) { // 遍历字符串直到遇到终止符
        if (!isalpha(str[i])) { // 判断是否为字母
        // 也可以使用 (str[i] < 'A' || (str[i] > 'Z' && str[i] < 'a') || str[i] > 'z')
            str[i] = ' '; // 替换为空格字符
        }
    } // 由于 str 是数组参数，修改会直接影响原字符串
}
```

---

# C 语言单词处理（2，6 分）

函数 `int LongestWord(char str[])`
- 该函数的功能是将字符串 `str` 中最长单词的长度计算出来，并作为函数的值返回。
- 单词之间是用空格分隔开的。

---

# C 语言单词处理（2）分析

我们需要遍历字符串，统计每个单词的长度，并记录最长单词的长度。
可以设置一个最大长度变量 `maxLen` 和当前单词长度变量 `currentLen`，同时，当我们遇到空格时，表示一个单词结束，我们需要更新最大长度并重置当前长度，否则就增加当前单词长度。
```c
int LongestWord(char str[]) {
    int maxLen = 0, currentLen = 0; // 用于记录最大和当前单词长度
    for (int i = 0; str[i] != '\0'; ++i) { // 遍历字符串直到遇到终止符
        if (str[i] != ' ') currentLen++; // 如果不是空格，表示在单词中，增加当前单词长度
        else { // 遇到空格，表示单词结束
            if (currentLen > maxLen) maxLen = currentLen; // 更新最大长度
            currentLen = 0; // 重置当前单词长度
        }
    }
    // 特别注意：最后还需要检查一次，以防字符串以非空格结尾
    if (currentLen > maxLen) maxLen = currentLen;
    return maxLen; // 返回最长单词长度
}
```

---

# C 语言单词处理（3，4 分）

主函数 `int main()`
- 定义拟处理的字符串 `str` 等局部变量，已知 `str` 的长度不超过 $100$。
- 从键盘读入一个以回车为结尾的字符串 `str`。
- 调用 `MyReplace` 函数对 `str` 进行替换操作；调用 `LongestWord` 函数计算出 `str` 中最长单词的长度。
- 输出最长单词的长度值。

---

# C 语言单词处理（3）分析

在主函数中，我们需要定义一个字符数组来存储输入的字符串，然后使用 `fgets` 函数读取输入，调用前面定义的两个函数进行处理，并输出结果。
```c
#include <stdio.h>
const int MAX_LENGTH = 100;
int main() {
    char str[MAX_LENGTH + 1]; // 定义字符串数组，长度为 100 + 1（包括终止符）
    puts("Please input str:");
    fgets(str, MAX_LENGTH + 1, stdin); // 从键盘读入字符串
    MyReplace(str); // 调用替换函数
    puts("The replaced str is:");
    puts(str); // 输出替换后的字符串
    int len = LongestWord(str); // 调用计算最长单词长度函数
    // 输出最长单词长度
    printf("The length of the longest word in the line is: %d.\n", len);
    return 0;
}
```
---

# C 语言递归编程（5 分）

请按照要求编写递归函数和程序，实现字符串消除。已知待处理的字符串 `str` 的长度不超过 $100$。

递归函数 `Eliminate()`
- 使用递归的方法，对字符串中的一些字符按照要求的规则进行消除
- 字符消除规则：
  - 按照自右至左的优先顺序扫描，对连续出现 $3$ 次及以上的字符进行消除；
  - 对于字符串重复进行上述消除操作。
- 消除操作的举例：
  - `123332211`->`122211`->`111`->`""`，结果为空字符串。
  - `123332221`->`123331`->`121`，结果为字符串 `121`。
  - `1234444332221`->`1234444331`->`123331`->`121`，结果为字符串 `121`。

---

# C 语言递归编程分析

对于 `Eliminate` 函数，我们预期其函数体主要部分的作用是扫描字符串，找到连续出现 3 次及以上的字符并进行消除。
考虑递归的三个部分：
- 递归终止条件：没有进行消除或不存在连续 3 次及以上的字符时，递归终止
- 递归调用过程：扫描并消除连续字符后，重复调用 `Eliminate` 函数
- 子任务的结果合并：由于字符串是直接在原数组上进行修改，因此不需要额外的结果合并

---

# C 语言递归编程实现

```c
#include <string.h>
void Eliminate(char str[]) {
    char newStr[MAX_LENGTH + 1]; // 用于存储消除后的新字符串
    int len = strlen(str), count = 0, newIndex = 0; // 获取字符串长度，计数器和新字符串索引
    char lastChar = '\0'; // 记录当前字符
    for (int i = len - 1; i >= 0; --i) { // 自右至左扫描字符串
        if (str[i] == lastChar) {
            count++; // 计数连续相同字符
        } else { // 遇到不同字符
            if (count < 3) { // 如果连续字符少于 3 次，保留
                for (int j = 0; j < count; ++j) {
                    newStr[newIndex++] = lastChar; // 将字符复制到新字符串
                }
            }
            lastChar = str[i]; // 更新当前字符
            count = 1; // 重置计数器
        }
    }
    // 循环后续...
}
```

---

# C 语言递归编程实现（续）

```c
void Eliminate(char str[]) {
    // 前面部分同上...
    if (count < 3) { // 处理最后一组字符
        for (int j = 0; j < count; ++j) {
            newStr[newIndex++] = lastChar;
        }
    }
    // 将新字符串反转并放回
    for (int i = 0; i < newIndex; ++i) {
        str[i] = newStr[newIndex - 1 - i];
    }
    str[newIndex] = '\0'; // 添加字符串终止符
    // 递归调用
    if (newIndex < len) { // 如果有字符被消除，继续递归
        Eliminate(str);
    }
}
```

---

# C 语言递归编程（续）

主函数 `main()`
- 定义相关的局部变量，从键盘输入一个字符串。
- 调用编写的递归函数，进行字符消除操作。
- 输出处理后的字符串。

---

# C 语言递归编程主函数实现

```c
#include <stdio.h>
const int MAX_LENGTH = 100;
int main() {
    char str[MAX_LENGTH + 1]; // 定义字符串数组
    printf("请输入字符串：");
    scanf("%s", str); // 从键盘输入字符串
    Eliminate(str); // 调用递归函数进行消除
    printf("消除后的字符串：%s\n", str); // 输出处理后的字符串
    return 0;
}
```

---

<h1><center>Thanks!</center></h1>

<div align=center><img src="2025秋-自52.png"></div>